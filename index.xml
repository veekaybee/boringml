<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Boring Machine Learning</title><link>http://boringml.com/</link><description>Recent content in Introduction on Boring Machine Learning</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://boringml.com/index.xml" rel="self" type="application/rss+xml"/><item><title>build.sbt and build.Scala</title><link>http://boringml.com/docs/languages/scala/build-sbt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/scala/build-sbt/</guid><description>Building Scala code # SBT, along with Maven, is a default way to build Scala applications. build.sbt is the file that defines how your project is built, but sometimes you&amp;rsquo;ll also see build.scala files in specific projects.
build.scala is the more advanced version of the build.sbt file, and often is used for more complicated projects.
Here&amp;rsquo;s an example of the difference between .sbt and .scala build files:
build.sbt
name := &amp;quot;hello&amp;quot; version := &amp;quot;1.</description></item><item><title>is_set</title><link>http://boringml.com/docs/languages/java/arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/java/arrays/</guid><description>Is set versus array_key_exists # I dug into the performance of isset versus array_key_exists in PHP.
Both look at an array and determine if it has a specific key, but their behavior is different.
isset will return false if the value of that key is null. array_key_exists will only look at the key itself.
Using an id as an example:
$a = array(&amp;#39;1&amp;#39; =&amp;gt; &amp;#39;`12345678`&amp;#39;, &amp;#39;key2&amp;#39; =&amp;gt; null); isset($a[&amp;#39;key1&amp;#39;]); //true isset($a[&amp;#39;key2&amp;#39;]); //false array_key_exists(&amp;#39;key1&amp;#39;, $a); // true array_key_exists(&amp;#39;key2&amp;#39;, $a); //true So if you want your function to be null-safe, isset is always the best best.</description></item><item><title>is_set</title><link>http://boringml.com/docs/languages/php/arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/php/arrays/</guid><description>Is set versus array_key_exists # I dug into the performance of isset versus array_key_exists in PHP.
Both look at an array and determine if it has a specific key, but their behavior is different.
isset will return false if the value of that key is null. array_key_exists will only look at the key itself.
Using an id as an example:
$a = array(&amp;#39;1&amp;#39; =&amp;gt; &amp;#39;`12345678`&amp;#39;, &amp;#39;key2&amp;#39; =&amp;gt; null); isset($a[&amp;#39;key1&amp;#39;]); //true isset($a[&amp;#39;key2&amp;#39;]); //false array_key_exists(&amp;#39;key1&amp;#39;, $a); // true array_key_exists(&amp;#39;key2&amp;#39;, $a); //true So if you want your function to be null-safe, isset is always the best best.</description></item><item><title>Legible SQL</title><link>http://boringml.com/docs/languages/sql/legible-sql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/sql/legible-sql/</guid><description>Writing legible code is seen as the hallmark of a competent developer, and for good reason. If you can&amp;rsquo;t read what you wrote, you can&amp;rsquo;t change what you wrote. There are lots of organizations, especially once you get to larger companies where programming isn&amp;rsquo;t the core competency or value center, that are prime examples of this. The result is a mess that not only impacts the code, but the entire company or business.</description></item><item><title>strptime and strftime</title><link>http://boringml.com/docs/languages/python/strptime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/python/strptime/</guid><description>One weird trick about Python date formats # I&amp;rsquo;ve been working with date manipulation in Python as part ofthis Reddit challenge, which asks the programmer to find the year(s) in history when the most US presidents were alive given each president&amp;rsquo;s birth and death date.
Usually, when working with dates and times in programming, it&amp;rsquo;s best to convert to object types that inherently have some assumptions about time and date already built in to allow for easy addition, subtraction, and date conversion.</description></item><item><title>venv</title><link>http://boringml.com/docs/languages/python/venv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/languages/python/venv/</guid><description>Creating a new venv # source
Whosoever makes a static webpage that just has two things on it:
1. Unix/Mac/Windows command for creating a new venv environment
2. Unix/Mac/Windows command for activating new venv environment
will achieve super-high search rankings almost instantaneously.
&amp;mdash; Vicki (implicit) (@vboykis) October 8, 2019 Instructions # cd project_folder virtualenv venvname source venvname/bin/activate</description></item><item><title>Kubernetes</title><link>http://boringml.com/docs/platforms/kubernetes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/platforms/kubernetes/</guid><description>Kubernetes Cheat Sheet # What is it? Kubernetes is just a bunch of Docker containers that are abstracted away from you and that you operate on in a group.
Frequently used shortcuts:
// see clusters available to you kubectl config view // pick cluster kubectl config use-context dca-production // which namespaces do we have kubectl get namespace | wc -l 65 // how many pods do we have running in our namespace?</description></item><item><title>Implementing Minhash</title><link>http://boringml.com/docs/recsys/minhash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/recsys/minhash/</guid><description>Chapter 3 of Mining Massive DataSets # Chapter Slides
Motivating the Chapter
We cover the first part of this chapter, which deals with Jaccard similarity, shingling, and minhash.
Often these days data analysis involves datasets that have high dimensionality, meaning the data set in question has more features than values and to make statistically sound inferences at scale, require large amounts of data (more info here, on p. 22), and it’s these kinds of datasets that Chapter 3 deals with.</description></item><item><title>Recsys Syllabus</title><link>http://boringml.com/docs/recsys/recsys-syllabus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/recsys/recsys-syllabus/</guid><description>System design
Reading Google Intro to Recsys Course Recsys Algorithms
Collaborative Filtering Reading:Amazon Paper Collaborative Filter Survey Paper Matrix Factorization - Reading: Netflix Prize paper Content Filtering - Twitter Paper Hybrid Recommenders: Collaborative + Content Based Methods
Personalization](https://eugeneyan.com/writing/patterns-for-personalization) Multiarmed Bandits Embeddings Overview and Overview Random Walk - Pixie Definitions of similarity/distance in personalized algos Candidate Generation Process Candidate Ranking Process Recsys Evaluation Metrics:</description></item><item><title>What is machine learning engineering?</title><link>http://boringml.com/docs/what-is-ml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/what-is-ml/</guid><description>What is machine learning engineering? # Once, on a crisp cloudless morning in early fall, a machine learning engineer left her home to seek the answers that she could not find, even in the newly-optimized Google results.
She closed her laptop, put on her backpack and hiking boots, and walked quietly out her door and past her mailbox, down a dusty path that led past a stream, until the houses around her gave way to broad fields full of ripening corn.</description></item><item><title>About Me</title><link>http://boringml.com/docs/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/about/</guid><description>About Me # Hi! I&amp;rsquo;m Vicki. I&amp;rsquo;m a machine learning engineer at Tumblr. working on recommender systems with deep expertise in YAML indentation. I live in Philly with my family. In my free time, I love to write about Life. I also like to think about what technology means in the context of society, and write about that, as well. My main site is here.
I also love tweeting terrible puns and doodling tech logos.</description></item><item><title/><link>http://boringml.com/docs/recsys/jaccard-similarity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/recsys/jaccard-similarity/</guid><description>Jaccard Similarity # Implemented two different ways:
import numpy as numpy import typing a = [1,2,3,4,5,11,12] b = [2,3,4,5,6,8,9] cats = [&amp;#34;calico&amp;#34;, &amp;#34;tabby&amp;#34;, &amp;#34;tom&amp;#34;] dogs = [&amp;#34;collie&amp;#34;, &amp;#34;tom&amp;#34;,&amp;#34;bassett&amp;#34;] def jaccard(list1: list, list2: list)-&amp;gt; float: intersection = len(list(set(list1).intersection(list2))) union = (len(set((list1)) + set(len(list2))) - intersection return float(intersection/union) print(jaccard(cats,dogs)) jaccardSimilarity in Scala # val aVals: Seq[Int] = Seq(1,2,3,4,5,11,12) val bVals: Seq[Int] = Seq(2,3,4,5,6,8,9) def calculateJaccard[T](a: Seq[T], b: Seq[T]): Double = a.</description></item><item><title>Airflow</title><link>http://boringml.com/docs/platforms/airflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/platforms/airflow/</guid><description>Airflow Callbacks #</description></item><item><title>Hash aggregates</title><link>http://boringml.com/docs/computer-science/hash-aggregate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/computer-science/hash-aggregate/</guid><description>This post is an expansion of this tweet:
If I had to pick a single programming concept where understanding it is like a superpower, it would probably be the hash map (aka in Python, the humble dictionary) because I&amp;#39;ve seen the pattern come up in almost every kind of data/programming work I&amp;#39;ve ever done.
&amp;mdash; Vicki (implicit) (@vboykis) July 8, 2020 Hash Aggregate Here # But data work also has its own unique patterns, and I want to talk about one of these that I think is important for all of us to carry around in our back pockets: the humble hash aggregate.</description></item><item><title>Lambdas</title><link>http://boringml.com/docs/platforms/cloud/aws/lambdas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/platforms/cloud/aws/lambdas/</guid><description>asdfsadfsafs</description></item><item><title>Precision and Recall</title><link>http://boringml.com/docs/recsys/precision-and-recall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/recsys/precision-and-recall/</guid><description>Precision and Recall
Precision and recall are common ways to evaluate the accuracy of your machine learning or information retrieval model. In other contexts, such as statistics, the measurements around these terms is also known as Type I/Type II errors.
Let’s say you’re working on understanding the relevancy of SnakeSearch, a search engine that looks to find relevant Python documentation for you. Let’s say you want to find documents related to Pandas, as you’re getting started with Pandas, the Python software library, and want some information.</description></item><item><title>Sample data in PySpark</title><link>http://boringml.com/docs/platforms/spark/create-data-python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/platforms/spark/create-data-python/</guid><description>Here&amp;rsquo;s how to create a small fake dataset for testing in PySpark. More on sc.parallelize.
from pyspark.sql.session import SparkSession rdd = sc.parallelize([(0,None), (0,1), (0,2), (1,2), (1,10), (1,20), (3,18), (3,18), (3,18)]) df=rdd.toDF([&amp;#39;id&amp;#39;,&amp;#39;score&amp;#39;]) df.show() +---+-----+ | id|score| +---+-----+ | 0| null| | 0| 1| | 0| 2| | 1| 2| | 1| 10| | 1| 20| | 3| 18| | 3| 18| | 3| 18| +---+-----+ df.printSchema() root |-- id: long (nullable = true) |-- score: long (nullable = true) None is a special keyword in Python that will let you create nullable fields.</description></item><item><title>Writing Unit Tests for Spark Apps in Scala</title><link>http://boringml.com/docs/platforms/spark/testing-dataframes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://boringml.com/docs/platforms/spark/testing-dataframes/</guid><description>Writing Unit Tests for Spark Apps in Scala # Often, something you’d like to test when you’re writing self-contained Spark applications, is whether your given work on a DataFrame or Dataset will return what you want it to after multiple joins and manipulations to the input data.
This is not different from traditional unit testing, with the only exception that you&amp;rsquo;d like to test and introspect not only the functionality of the code but the data itself.</description></item></channel></rss>